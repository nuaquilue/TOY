---
title: "Neutral landscapes models to generate forest landscapes and delimit forest stands"
author: "Núria Aquilué"
date: "5/3/2020"
output:  pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(landscapemetrics)
library(NLMR)
library(igraph)
library(sp)
library(raster)
library(viridis)
library(tidyverse)
ncol=nrow=201 ##101
```

## Introduction and aim

Neutral landscape models (NLMs) have been extensively used in landscape ecology studies to represent and analayze broad-scale landscape patterns. NLMs are not exact reproductions of real-world landscapes, but sound representations useful to test hypotesis about the effects of landscape structure on ecological processes.  

Here, I present a few well-known NLMs to create neutral landscape resembling real-world forest landscapes and to split forest areas in forest stands.


## Forest landscapes

The following examples are 201 x 201 landscapes with ~50% of forest created by three different NLMs. For each NLM, a more aggregate versus a sparser pattern are generated by varying the master parameter specific of each NLM.  

1. A **random cluster** model with relative abundance *r*=(0.5, 0.5), and the proportion of elements randomly selected to form clusters *p*=0.4 and *p*=0.28, respectively.  
```{r rc, echo=F}
LANDrc1 <- nlm_randomcluster(ncol, nrow, resolution=100, p=0.4, ai=c(0.5, 0.5), neighbourhood=8, rescale=F)
LANDrc2 <- nlm_randomcluster(ncol, nrow, resolution=100, p=0.28, ai=c(0.5, 0.5), neighbourhood=8, rescale=F)
par(mfrow=c(1,2))
plot(LANDrc1, legend=F); plot(LANDrc2, legend=F) 
```

2. A **fractional Brownian motion** model with weights *w*=(0.5, 0.5) and fractal dimension *f*=0.8 and *f*=0.2, respectively, reclassified at 2 categories.  
```{r fbm, echo=F}
LANDfbm1 <- nlm_fbm(ncol, nrow, resolution=100, fract_dim=0.8)
LANDfbm1 <- landscapetools::util_classify(LANDfbm1, weighting = c(0.5, 0.5))
LANDfbm2 <- nlm_fbm(ncol, nrow, resolution=100, fract_dim=0.2)
LANDfbm2 <- landscapetools::util_classify(LANDfbm2, weighting = c(0.5, 0.5))
# table(LANDfbm1[]-1); table(LANDfbm[]-1)
par(mfrow=c(1,2))
plot(LANDfbm1, legend=F); plot(LANDfbm2, legend=F) 
```

3. A **random neighborhood** model with probability contagion and emergence *pc*=0.99 - *pe*=0.01 and  *pc*=0.5 - *pe*=0.5, respectively, reclassified at 2 categories.  
```{r rngh, echo=F}
LANDngh1 <- nlm_neigh(ncol, nrow, resolution=100, p_neigh=0.99, p_empty=0.01, categories=2, neighbourhood=8, rescale=F)
LANDngh2 <- nlm_neigh(ncol, nrow, resolution=100, p_neigh=0.5, p_empty=0.5, categories=2, neighbourhood=8, rescale=F)   
par(mfrow=c(1,2))
plot(LANDngh1, legend=F); plot(LANDngh2, legend=F)
```


## Forest stands

Once a landscape is initialized with 2 land-cover types (forest vs. non-forest), forest areas need to be split in forest stands (or patches). I use similar NLMs to differenciate forest stands within forest areas. In the following examples, forest stands are visually differenciated by color. However, this does not mean that forest stands represented by the same color will be populated by the same tree community. The assignation of representative tree communities will be done in an independent process, after forest stands are delinated. It is worth nothing that by this approach, some adjacent forest stands could eventually be populated with identical tree communities (then becoming a single, bigger forest stand), unless this situation is explicitly avoided by the algorithm in charge of populating forest stands with tree communities.  

4. A **random cluster** model with **3 categories**, relative abundance *r*=(0.4, 0.3, 0.3), and the proportion of elements randomly selected to form clusters *p*=0.4 and *p*=0.28, respectively. The first category represents the non-forest area of the landscape. The stocasticty of the random cluster model makes hard to generate a landscape with an exact 50% occupancy by forests.  
```{r rnd12, echo=F}
LANDrnd1 <- nlm_randomcluster(ncol, nrow, resolution=100, p=0.4, ai=c(0.4, 0.3, 0.3), neighbourhood=8, rescale=F)
LANDrnd2 <- nlm_randomcluster(ncol, nrow, resolution=100, p=0.28, ai=c(0.4, 0.3, 0.3), neighbourhood=8, rescale=F)
par(mfrow=c(1,2))
plot(LANDrnd1-1, legend=T, col=c("grey90", viridis(2))) 
plot(LANDrnd2-1, legend=T, col=c("grey90", viridis(2))) 
```

5. A **random cluster** model with **5 categories**, relative abundance *r*=(0.35, 0.05, 0.25, 0.15, 0.2), and probability *p*=0.4 and *p*=0.28, respectively.  
```{r rnd34, echo=F}
LANDrnd3 <- nlm_randomcluster(ncol, nrow, resolution=100, p=0.4, ai=c(0.35, 0.05, 0.25, 0.15, 0.2), neighbourhood=8, rescale=F)
LANDrnd4 <- nlm_randomcluster(ncol, nrow, resolution=100, p=0.28, ai=c(0.35, 0.05, 0.25, 0.15, 0.2), neighbourhood=8, rescale=F)
par(mfrow=c(1,2))
plot(LANDrnd3-1, legend=T, col=c("grey90", viridis(4))) 
plot(LANDrnd4-1, legend=T, col=c("grey90", viridis(4))) 
```

6. A **random cluster** model with **7 categories**, relative abundance *r*=(0.2, 0.1, 0.05, 0.05, 0.25, 0.15, 0.2), and probability *p*=0.4 and *p*=0.28, respectively.  
```{r rnd56, echo=F}
LANDrnd5 <- nlm_randomcluster(ncol, nrow, resolution=100, p=0.4, ai=c(0.2, 0.1, 0.05, 0.05, 0.25, 0.15, 0.2), neighbourhood=8, rescale=F)
LANDrnd6 <- nlm_randomcluster(ncol, nrow, resolution=100, p=0.28, ai=c(0.2, 0.1, 0.05, 0.05, 0.25, 0.15, 0.2), neighbourhood=8, rescale=F)
par(mfrow=c(1,2))
plot(LANDrnd5-1, legend=T, col=c("grey90", rainbow(6))) 
plot(LANDrnd6-1, legend=T, col=c("grey90", rainbow(6))) 
```

7. Use first a **midpoint displacement** model reclassified at 2 categories to determine forest vs. non-forest (this approach returns a true 50% of occupancy).   
```{r mpd, echo=F}
LANDmpd1 <- nlm_mpd(ncol, nrow, resolution=100, roughness=0.65, rand_dev=1, rescale = F, verbose = F)
LANDmpd1 <- landscapetools::util_classify(LANDmpd1, weighting = c(0.5, 0.5))
LANDmpd2 <- nlm_mpd(ncol, nrow, resolution=100, roughness=0.98, rand_dev=2, rescale = F, verbose = F)
LANDmpd2 <- landscapetools::util_classify(LANDmpd2, weighting = c(0.5, 0.5))
par(mfrow=c(1,2))
plot(LANDmpd1, legend=F); plot(LANDmpd2, legend=F) 
```
7.1. Then, use a **random cluster** model with **2 categories**, relative abundance *r*=(0.6, 0.4), and probability *p*=0.4 and *p*=0.28, respectively, to split the forest area of previous landscapes in forest stands.  
```{r mpd.s1, echo=F}
stands <- nlm_randomcluster(ncol, nrow, resolution=100, p=0.28, ai=c(0.6, 0.4), neighbourhood=8, rescale=F)
LANDmpd1.s1 <- (LANDmpd1-1)*stands
LANDmpd2.s1 <- (LANDmpd2-1)*stands
par(mfrow=c(1,2))
plot(LANDmpd1.s1, legend=T, col=c("grey90", viridis(2))) 
plot(LANDmpd2.s1, legend=T, col=c("grey90", viridis(2)))
```

7.2. A **random cluster** model with **4 categories**, relative abundance *r*=c(0.5, 0.3, 0.1, 0.1), and probability *p*=0.4 and *p*=0.28, respectively, to split the forest area of previous landscapes in forest stands.  
```{r mpd.s2, echo=F}
stands <- nlm_randomcluster(ncol, nrow, resolution=100, p=0.28, ai=c(0.5, 0.3, 0.1, 0.1), neighbourhood=8, rescale=F)
LANDmpd1.s2 <- (LANDmpd1-1)*stands
LANDmpd2.s2 <- (LANDmpd2-1)*stands
par(mfrow=c(1,2))
plot(LANDmpd1.s2, legend=T, col=c("grey90", viridis(4))) 
plot(LANDmpd2.s2, legend=T, col=c("grey90", viridis(4)))
```

7.3. A **random cluster** model with **6 categories**,relative abundance *r*=c(0.25, 0.1, 0.15, 0.3, 0.1, 0.1), and probability *p*=0.4 and *p*=0.28, respectively, to split the forest area of previous landscapes in forest stands.  
```{r mpd.s3, echo=F}
stands <- nlm_randomcluster(ncol, nrow, resolution=100, p=0.28, ai=c(0.25, 0.1, 0.15, 0.3, 0.1, 0.1), neighbourhood=8, rescale=F)
LANDmpd1.s3 <- (LANDmpd1-1)*stands
LANDmpd2.s3 <- (LANDmpd2-1)*stands
par(mfrow=c(1,2))
plot(LANDmpd1.s3, legend=T, col=c("grey90", rainbow(6))) 
plot(LANDmpd2.s3, legend=T, col=c("grey90", rainbow(6))) 
```

7.4. If forest stands within forest areas are too compact or spatially homogeneous, a random cluster approach can be used to first split the forest area in forest stands and then add some "salt-and-pepper" effect. The following two examples populate with 4-color forest stands the forest landscapes created in section 7.  
```{r mpd.s4, echo=F}
stands <- nlm_randomcluster(ncol, nrow, resolution=100, p=0.28, ai=c(0.6, 0.4), neighbourhood=8, rescale=F)
LANDmpd1.s4 <- (LANDmpd1-1)*stands*sample(c(1,3), ncell(stands), replace = T, prob=c(0.7,0.3))
LANDmpd1.s4 <- subs(LANDmpd1.s4, data.frame(from=c(0,1,2,3,6), to=0:4))
LANDmpd2.s4 <- (LANDmpd2-1)*stands*sample(c(1,3), ncell(stands), replace = T, prob=c(0.7,0.3))
LANDmpd2.s4 <- subs(LANDmpd2.s4, data.frame(from=c(0,1,2,3,6), to=0:4))
par(mfrow=c(1,2))
plot(LANDmpd1.s4, legend=T, col=c("grey90", viridis(4))) 
plot(LANDmpd2.s4, legend=T, col=c("grey90", viridis(4)))
```

7.5. The same approach of 7.4 but with 6-color forest stands.    
```{r mpd.s5, echo=F}
LANDmpd1.s5 <- LANDmpd1.s2*sample(c(1,2), ncell(stands), replace = T, prob=c(0.3,0.7))
LANDmpd1.s5 <- subs(LANDmpd1.s5, data.frame(from=c(0,1,2,3,4,6,8), to=0:6))
LANDmpd2.s5 <- LANDmpd2.s2*sample(c(1,2), ncell(stands), replace = T, prob=c(0.3,0.7))
LANDmpd2.s5 <- subs(LANDmpd2.s5, data.frame(from=c(0,1,2,3,4,6,8), to=0:6))
par(mfrow=c(1,2))
plot(LANDmpd1.s5, legend=T, col=c("grey90", rainbow(6))) 
plot(LANDmpd2.s5, legend=T, col=c("grey90", rainbow(6))) 
```

8. Idem as 7., that is use any of the first NLM presented or similar to categorise first the landscape in forest vs. non-forest and then use a **random cluster** model (with or without adding "salt-and-pepper"effect) to split the forest area in forest stands. For example use a random model with
relative abundance *r*=(0.5, 0.5) and probability *p*=0.4 to create the landscape and a second random model with relative abundance *r*=(0.4, 0.3, 0.15, 0.15) and probability *p*=0.28 to split the forest area in stands.  
```{r extra, echo=F}
LANDrc <- nlm_randomcluster(ncol, nrow, resolution=100, p=0.4, ai=c(0.5, 0.5), neighbourhood=8, rescale=F)
stands <- nlm_randomcluster(ncol, nrow, resolution=100, p=0.28, ai=c(0.4, 0.3, 0.15, 0.15), neighbourhood=8, rescale=F)
LANDrc.s <- (LANDrc-1)*stands
par(mfrow=c(1,2))
plot(LANDrc-1, legend=F); plot(LANDrc.s, col=c("grey90", viridis(4)))
```


## Tree communities

Once characteristic tree communities are defined, assign a tree community to every forest stands (i.e. populate forest stands) can be done either at random or following a clustering approach that takes into account that some specific tree communities are likely to be found close to other types of tree commuities. To reproduce this pattern, a cellular automata approach could be implemented to assign tree communities according to those of neighboring forest stands.  


## Recap

The possibilites of generate first a forest landscape, then to split forest area in forest stands are endeless, as well as populate forest stands with representative tree communities.

Main decisions relative at setting-up a **forest landscape** are:  
- The percentage of forest occupancy (in the above examples, that ~50% of the landscape is covered by forest is the first arbitrary decision made).  
- The distribution of forest areas will determine the number, size, shape, fractality, and spatial allocation  (or viceversa).  

Main decisions relative at setting-up **forest stands** are:  
- The size distribution (mean and sd).  
- Shape (circular vs. squared vs. irregular), fractality (smooth vs. wrinkled), and compactness (with or without gaps).  

Main decisions relative at setting-up **tree communities** are:  
- Key tree species (with specific effect and response traits, mode of reproduction and see dispersal capacity).  
- Species or functional group composition.  
- Relative abundance of each tree community within a forest landscape.  


## Next steps

a. We should find benchmark landscapes, forest stands, and tree communities as well as landscape-level, patch-level, and community-level metrics to help us in generating contrasting but at the same time realistic forest landscapes.  

b. List representative species of the biomes of interest, list functional traits of interest, and look up for functional traits values and seed dispersal capacity.  

c. Choose!    

*Suggestions, ideas, comments,... are welcomed!*   